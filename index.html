<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>グループ分け最適化サイト</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        .participant-input, .pair-input { margin-bottom: 10px; }
        .container { margin-top: 20px; }
        .delete-button {
            display: inline-block;
            margin-left: 20px;
            width: 30px;
            height: 30px;
            border-radius: 15px; /* ボタンを丸くする */
            border: none; /* 枠線を消す */
            background-color: #cccccc; /* 薄いグレー色 */
            color: white; /* 文字色 */
            font-weight: bold; /* 文字を太く */
            cursor: pointer; /* マウスカーソルをポインターに */
        }

        /* ボタンのホバー効果 */
        .delete-button:hover {
            background-color: #bbbbbb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">グループ分け最適化サイト</h1>
        <form id="seatingForm">
            <div id="participants" class="mb-3">
                <!-- 参加者情報入力欄がここに挿入されます -->
            </div>
            <button type="button" class="btn btn-primary mb-3" id="addParticipant">参加者追加</button>

            <div id="goodPairs" class="mb-3">
                <h3>仲良し度の高いペア</h3>
                <!-- 仲の良いペアの入力フィールドがここに挿入されます -->
            </div>
            <button type="button" class="btn btn-info mb-3" id="addGoodPair">高仲良し度ペア追加</button>
            
            <div id="badPairs" class="mb-3">
                <h3>仲良し度の低いペア</h3>
                <!-- 仲の悪いペアの入力フィールドがここに挿入されます -->
            </div>
            <button type="button" class="btn btn-info mb-3" id="addBadPair">低仲良し度ペア追加</button>

            <div class="mb-3">
                <label>テーブル数(半角整数)</label>
                <input type="number" name="num_tables" class="form-control" required>
            </div>
            <div class="mb-3">
                <label>各テーブルの席数(例:3,4,5)</label>
                <input type="text" name="table_capacities" class="form-control" required>
            </div>
            <input type="submit" class="btn btn-success" value="座席決定">
            <button type="button" class="btn btn-danger" id="clearResults" style="display: none;">クリア</button>            
        </form>

        <div id="result" class="mt-3">
            <!-- 計算結果がここに表示されます -->
        </div>
    </div>

    <script>
        class Person {
            constructor(name, department, career) {
                this.name = name;
                this.department = department;
                this.career = career;
            }
        }
        class Table {
            constructor(capacity, seats = []) {
                this.capacity = capacity;
                this.seats = seats;
            }

            addPerson(person) {
                if (this.seats.length < this.capacity) {
                    this.seats.push(person);
                } else {
                    console.log("Table is full");
                }
            }
        }
        
        function addParticipant() {
            const participantsDiv = document.getElementById("participants");
            const newIndex = document.querySelectorAll('.participant-input').length + 1;
            const participantHTML = `
                <div class="participant-input">
                    名前: <input type="text" name="name${newIndex}" required>
                    部署: <input type="text" name="department${newIndex}" required>
                    年次: <input type="number" name="career${newIndex}" min="0" required>
                    <button type="button" class="delete-button" onclick="this.parentNode.remove();">✕</button>
                </div>
            `;
            participantsDiv.insertAdjacentHTML('beforeend', participantHTML);
        }
        function addPair(pairType) { // pairTypeは 'good' または 'bad' の文字列
            const pairsDiv = document.getElementById(`${pairType}Pairs`);
            const newIndex = document.querySelectorAll(`.${pairType}-pair-input`).length + 1;
            const pairHTML = `
                <div class="${pairType}-pair-input">
                    名前1: <input type="text" name="${pairType}Name1_${newIndex}">
                    名前2: <input type="text" name="${pairType}Name2_${newIndex}">
                    <button type="button" class="delete-button" onclick="this.parentNode.remove();">✕</button>
                </div>
            `;
            pairsDiv.insertAdjacentHTML('beforeend', pairHTML);
        }
        
        // 親和性行列の生成
        function generateAffinityMatrix(people, goodPairs, badPairs) {
            const size = people.length;
            const matrix = Array.from({ length: size }, () => Array(size).fill(0));

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (i === j) continue; // 同一人物の比較をスキップ
                    const person1 = people[i];
                    const person2 = people[j];

                    // 部署が異なる場合のスコア
                    if (person1.department !== person2.department) {
                        matrix[i][j] += 20;
                    }

                    // キャリアの差に応じたスコア
                    const careerDiff = Math.abs(person1.career - person2.career);
                        matrix[i][j] += careerDiff*3;
                }
            }
            // 仲の良いペアと仲の悪いペアに基づいてaffinity_matrixを更新
            goodPairs.forEach(pair => {
                const index1 = people.findIndex(person => person.name === pair[0]);
                const index2 = people.findIndex(person => person.name === pair[1]);
                if (index1 !== -1 && index2 !== -1) {
                    matrix[index1][index2] = matrix[index2][index1] = -100; // 仲の良いペア
                }
            });

            badPairs.forEach(pair => {
                const index1 = people.findIndex(person => person.name === pair[0]);
                const index2 = people.findIndex(person => person.name === pair[1]);
                if (index1 !== -1 && index2 !== -1) {
                    matrix[index1][index2] = matrix[index2][index1] = 100; // 仲の悪いペア
                }
            });

            return matrix;
        }

        // コスト計算関数の実装
        function calculateCost(tables, affinityMatrix, people) {
            let totalCost = 0;

            tables.forEach(table => {
                table.seats.forEach((person, i) => {
                    const nextIndex = (i + 1) % table.seats.length;
                    const nextPerson = table.seats[nextIndex];
                    const personIndex = people.indexOf(person);
                    const nextPersonIndex = people.indexOf(nextPerson);

                    // 隣同士の人物に対するコスト
                    totalCost += 2 * affinityMatrix[personIndex][nextPersonIndex];

                    // テーブル内の他の全員とのコスト
                    for (let j = i + 1; j < table.seats.length; j++) {
                        const otherPerson = table.seats[j];
                        const otherPersonIndex = people.indexOf(otherPerson);
                        totalCost += affinityMatrix[personIndex][otherPersonIndex];
                    }
                });
            });

            return totalCost;
        }

        function createInitialSolution(people, tables) {
            // テーブルの新しいインスタンスを作成して、席をクリア
            let newTables = tables.map(table => new Table(table.capacity));

            // people配列のコピーをシャッフルする
            let shuffledPeople = [...people];
            for (let i = shuffledPeople.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledPeople[i], shuffledPeople[j]] = [shuffledPeople[j], shuffledPeople[i]];
            }

            // シャッフルされたpeopleを新しいテーブルに割り当てる
            shuffledPeople.forEach(person => {
                const availableTable = newTables.find(table => table.seats.length < table.capacity);
                if (availableTable) {
                    availableTable.addPerson(person);
                } else {
                    console.error('All tables are full. Cannot add more people.');
                }
            });

            return newTables; // 修正されたテーブルの配列を返す
        }

        function simulatedAnnealing(initialSolution, affinityMatrix, people, iterations, initialTemp, coolingRate) {
            let currentSolution = initialSolution;
            let currentCost = calculateCost(initialSolution, affinityMatrix, people);
            let bestSolution = currentSolution;
            let bestCost = currentCost;
            let temp = initialTemp;

            for (let i = 0; i < iterations; i++) {
                let newSolution = generateNewSolution(currentSolution, people);
                let newCost = calculateCost(newSolution, affinityMatrix, people);

                if (acceptanceProbability(currentCost, newCost, temp) > Math.random()) {
                    currentSolution = newSolution;
                    currentCost = newCost;

                    if (newCost < bestCost) {
                        bestSolution = newSolution;
                        bestCost = newCost;
                    }
                }

                temp *= coolingRate;
            }

            return { bestSolution, bestCost };
        }

        function acceptanceProbability(oldCost, newCost, temperature) {
            if (newCost < oldCost) {
                return 1.0;
            } else {
                return Math.exp((oldCost - newCost) / temperature);
            }
        }
        
        function generateNewSolution(currentSolution) {
            // 新しい解のスケルトンを作成
            let newSolution = currentSolution.map(table => new Table(table.capacity, table.seats.slice()));

            // 全席を平坦化した配列を作成
            let allSeats = [];
            newSolution.forEach((table, tableIndex) => {
                table.seats.forEach((seat, seatIndex) => {
                    allSeats.push({tableIndex, seatIndex, person: seat});
                });
            });

            // 全席からランダムに2つの席を選ぶ
            if (allSeats.length > 1) {
                let index1 = Math.floor(Math.random() * allSeats.length);
                let index2 = Math.floor(Math.random() * allSeats.length);
                while (index1 === index2) {
                    // 異なる席が選ばれるまで選び直し
                    index2 = Math.floor(Math.random() * allSeats.length);
                }

                // 選んだ2つの席の人物を交換
                let seat1 = allSeats[index1];
                let seat2 = allSeats[index2];
                [newSolution[seat1.tableIndex].seats[seat1.seatIndex], newSolution[seat2.tableIndex].seats[seat2.seatIndex]] = [seat2.person, seat1.person];
            }

            return newSolution;
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById("addParticipant").addEventListener("click", addParticipant);
            document.getElementById("addGoodPair").addEventListener("click", () => addPair('good'));
            document.getElementById("addBadPair").addEventListener("click", () => addPair('bad'));
            document.getElementById('clearResults').addEventListener('click', function(event) {
                event.preventDefault(); // ページ遷移を防止
                document.getElementById('result').innerHTML = ''; // 結果欄のみクリア
                this.style.display = 'none'; // クリアボタンを非表示にする
            });

            function collectPeopleData() {
                const people = [];
                document.querySelectorAll('.participant-input').forEach((participantDiv, index) => {
                    const name = participantDiv.querySelector(`input[name="name${index + 1}"]`).value;
                    const department = participantDiv.querySelector(`input[name="department${index + 1}"]`).value;
                    const career = parseInt(participantDiv.querySelector(`input[name="career${index + 1}"]`).value, 10);
                    people.push(new Person(name, department, career));
                });
                return people;
            }
            function collectGoodPairs() {
                const pairs = [];
                document.querySelectorAll('.good-pair-input').forEach(pairDiv => {
                    const name1 = pairDiv.querySelector(`input[name^="goodName1"]`).value;
                    const name2 = pairDiv.querySelector(`input[name^="goodName2"]`).value;
                    if (name1 && name2) {
                        pairs.push([name1, name2]);
                    }
                });
                return pairs;
            }

            function collectBadPairs() {
                const pairs = [];
                document.querySelectorAll('.bad-pair-input').forEach(pairDiv => {
                    const name1 = pairDiv.querySelector(`input[name^="badName1"]`).value;
                    const name2 = pairDiv.querySelector(`input[name^="badName2"]`).value;
                    if (name1 && name2) {
                        pairs.push([name1, name2]);
                    }
                });
                return pairs;
            }

            function collectTableData() {
                const numTables = parseInt(document.querySelector('input[name="num_tables"]').value, 10);
                const tableCapacities = document.querySelector('input[name="table_capacities"]').value.split(',').map(capacity => parseInt(capacity, 10));
                const tables = tableCapacities.map(capacity => new Table(capacity));
                return { tables, tableCapacities };
            }
            function displayResults(bestSolution, bestCost) {
                const resultDiv = document.getElementById('result');
                resultDiv.innerHTML = ''; // Clear previous results

                bestSolution.forEach((table, index) => {
                    const names = table.seats.map(person => person.name).join(', ');
                    const tableDiv = document.createElement('div');
                    tableDiv.textContent = `Table ${index + 1}: ${names}`;
                    resultDiv.appendChild(tableDiv);
                });

                const costDiv = document.createElement('div');
                costDiv.textContent = `Total Cost: ${bestCost}`;
                resultDiv.appendChild(costDiv);

                // 結果が表示されたので、クリアボタンを表示
                document.getElementById('clearResults').style.display = 'inline-block';
            }


            document.getElementById('seatingForm').addEventListener('submit', function(event) {
                event.preventDefault();
                // 結果欄に「計算中...」を表示
                const resultDiv = document.getElementById('result');
                resultDiv.innerHTML = '計算中...';
                // フォーム送信時の処理
                const people = collectPeopleData();
                const goodPairs = collectGoodPairs();
                const badPairs = collectBadPairs();
                const { tables } = collectTableData();
                const affinityMatrix = generateAffinityMatrix(people, goodPairs, badPairs);
                // 計算処理を非同期で実行する場合（例: setTimeoutを使用して非同期処理のシミュレート）
                setTimeout(() => {
                    const initialSolution = createInitialSolution(people, tables);
                    const { bestSolution, bestCost } = simulatedAnnealing(initialSolution, affinityMatrix, people, 1000000, 30.0, 0.999999);
                    
                    // 結果の表示
                    displayResults(bestSolution, bestCost);
                }, 0); // setTimeoutを使用する場合、実際のアプリケーションでは適切な非同期処理に置き換える
            });
        });
    </script>
</body>
</html>
