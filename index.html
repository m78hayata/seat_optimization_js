<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>座席決定アプリ</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        .participant-input, .pair-input { margin-bottom: 10px; }
        .container { margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">飲み会座席決定アプリ</h1>
        <form id="seatingForm">
            <div id="participants" class="mb-3">
                <!-- 参加者情報入力欄がここに挿入されます -->
            </div>
            <button type="button" class="btn btn-primary mb-3" id="addParticipant">参加者追加</button>

            <div id="goodPairs" class="mb-3">
                <h3>仲の良いペア</h3>
                <!-- 仲の良いペアの入力フィールドがここに挿入されます -->
            </div>
            <button type="button" class="btn btn-info mb-3" id="addGoodPair">仲の良いペア追加</button>
            
            <div id="badPairs" class="mb-3">
                <h3>仲の悪いペア</h3>
                <!-- 仲の悪いペアの入力フィールドがここに挿入されます -->
            </div>
            <button type="button" class="btn btn-info mb-3" id="addBadPair">仲の悪いペア追加</button>

            <div class="mb-3">
                <label>テーブル数:</label>
                <input type="number" name="num_tables" class="form-control" required>
            </div>
            <div class="mb-3">
                <label>各テーブルの席数:</label>
                <input type="text" name="table_capacities" class="form-control" required>
            </div>
            <input type="submit" class="btn btn-success" value="座席決定">
            <button type="button" class="btn btn-danger" id="clearResultButton" style="display:none;">結果削除</button>
        </form>

        <div id="result" class="mt-3">
            <!-- 計算結果がここに表示されます -->
        </div>
    </div>

    <script>
        class Person {
            constructor(name, gender, department, career) {
                this.name = name;
                this.gender = gender;
                this.department = department;
                this.career = career;
            }
        }
        class Table {
            constructor(capacity) {
                this.capacity = capacity;
                this.seats = [];
            }
        
            addPerson(person) {
                if (this.seats.length < this.capacity) {
                    this.seats.push(person);
                } else {
                    console.log("Table is full");
                }
            }
        }
        
        function addParticipant() {
            const participantsDiv = document.getElementById("participants");
            const newIndex = document.querySelectorAll('.participant-input').length + 1;
            const participantHTML = `
                <div class="participant-input">
                    名前: <input type="text" name="name${newIndex}" required>
                    性別: <select name="gender${newIndex}" required>
                        <option value="">選択...</option>
                        <option value="男性">男性</option>
                        <option value="女性">女性</option>
                        <option value="その他">その他</option>
                    </select>
                    部署: <input type="text" name="department${newIndex}" required>
                    キャリア: <input type="number" name="career${newIndex}" min="0" required>
                </div>
            `;
            participantsDiv.insertAdjacentHTML('beforeend', participantHTML);
        }
        function addPair(pairType) { // pairTypeは 'good' または 'bad' の文字列
            const pairsDiv = document.getElementById(`${pairType}Pairs`);
            const newIndex = document.querySelectorAll(`.${pairType}-pair-input`).length + 1;
            const pairHTML = `
                <div class="${pairType}-pair-input">
                    名前1: <input type="text" name="${pairType}Name1_${newIndex}" required>
                    名前2: <input type="text" name="${pairType}Name2_${newIndex}" required>
                </div>
            `;
            pairsDiv.insertAdjacentHTML('beforeend', pairHTML);
        }
        
        // 親和性行列の生成
        function generateAffinityMatrix(people) {
            const size = people.length;
            const matrix = Array.from({ length: size }, () => Array(size).fill(0));

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (i === j) continue; // 同一人物の比較をスキップ
                    const person1 = people[i];
                    const person2 = people[j];

                    // 部署が異なる場合のスコア
                    if (person1.department !== person2.department) {
                        matrix[i][j] += 20;
                    }

                    // キャリアの差に応じたスコア
                    const careerDiff = Math.abs(person1.career - person2.career);
                    if (careerDiff === 1) {
                        matrix[i][j] += 3;
                    } else if (careerDiff >= 10) {
                        matrix[i][j] += 5;
                    } else {
                        matrix[i][j] += 10;
                    }
                }
            }

            return matrix;
        }

        // コスト計算関数の実装
        function calculateCost(tables, affinityMatrix, people) {
            let totalCost = 0;

            tables.forEach(table => {
                table.seats.forEach((person, i) => {
                    const nextIndex = (i + 1) % table.seats.length;
                    const nextPerson = table.seats[nextIndex];
                    const personIndex = people.indexOf(person);
                    const nextPersonIndex = people.indexOf(nextPerson);

                    // 隣同士の人物に対するコスト
                    totalCost += 2 * affinityMatrix[personIndex][nextPersonIndex];

                    // テーブル内の他の全員とのコスト
                    for (let j = i + 1; j < table.seats.length; j++) {
                        const otherPerson = table.seats[j];
                        const otherPersonIndex = people.indexOf(otherPerson);
                        totalCost += affinityMatrix[personIndex][otherPersonIndex];
                    }
                });
            });

            return totalCost;
        }

        function createInitialSolution(people, tables) {
            // people配列のコピーをシャッフルする（Fisher-Yatesシャッフル）
            let shuffledPeople = people.slice();
            for (let i = shuffledPeople.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledPeople[i], shuffledPeople[j]] = [shuffledPeople[j], shuffledPeople[i]];
            }

            // シャッフルされたpeopleをテーブルに割り当てる
            shuffledPeople.forEach(person => {
                // 空きがあるテーブルを探す
                const availableTable = tables.find(table => table.seats.length < table.capacity);
                if (availableTable) {
                    availableTable.addPerson(person);
                } else {
                    console.error('All tables are full. Cannot add more people.');
                }
            });
        }

        function simulatedAnnealing(initialSolution, affinityMatrix, people, iterations, initialTemp, coolingRate) {
            let currentSolution = initialSolution;
            let currentCost = calculateCost(initialSolution, affinityMatrix, people);
            let bestSolution = currentSolution;
            let bestCost = currentCost;
            let temp = initialTemp;

            for (let i = 0; i < iterations; i++) {
                let newSolution = generateNewSolution(currentSolution, people);
                let newCost = calculateCost(newSolution, affinityMatrix, people);

                if (acceptanceProbability(currentCost, newCost, temp) > Math.random()) {
                    currentSolution = newSolution;
                    currentCost = newCost;

                    if (newCost < bestCost) {
                        bestSolution = newSolution;
                        bestCost = newCost;
                    }
                }

                temp *= coolingRate;
            }

            return { bestSolution, bestCost };
        }

        function acceptanceProbability(oldCost, newCost, temperature) {
            if (newCost < oldCost) {
                return 1.0;
            } else {
                return Math.exp((oldCost - newCost) / temperature);
            }
        }

        function generateNewSolution(currentSolution, people) {
            // 新しい解のスケルトンを作成
            let newSolution = currentSolution.map(table => new Table(table.capacity));

            // 人々をランダムにテーブルに割り当てる（シンプルな例として）
            people.forEach(person => {
                const tableIndex = Math.floor(Math.random() * newSolution.length);
                newSolution[tableIndex].addPerson(person);
            });

            // ここに席の交換ロジックを適用することも可能ですが、
            // この例ではシンプルさを保つために省略しています。

            return newSolution;
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById("addParticipant").addEventListener("click", addParticipant);
            document.getElementById("addGoodPair").addEventListener("click", () => addPair('good'));
            document.getElementById("addBadPair").addEventListener("click", () => addPair('bad'));

            function collectPeopleData() {
                const people = [];
                document.querySelectorAll('.participant-input').forEach((participantDiv, index) => {
                    const name = participantDiv.querySelector(`input[name="name${index + 1}"]`).value;
                    const gender = participantDiv.querySelector(`select[name="gender${index + 1}"]`).value;
                    const department = participantDiv.querySelector(`input[name="department${index + 1}"]`).value;
                    const career = parseInt(participantDiv.querySelector(`input[name="career${index + 1}"]`).value, 10);
                    people.push(new Person(name, gender, department, career));
                });
                return people;
            }
            function collectTableData() {
                const numTables = parseInt(document.querySelector('input[name="num_tables"]').value, 10);
                const tableCapacities = document.querySelector('input[name="table_capacities"]').value.split(',').map(capacity => parseInt(capacity, 10));
                const tables = tableCapacities.map(capacity => new Table(capacity));
                return { tables, tableCapacities };
            }
            function displayResults(bestSolution, bestCost) {
                const resultDiv = document.getElementById('result');
                resultDiv.innerHTML = ''; // Clear previous results

                bestSolution.forEach((table, index) => {
                    // table.seats は Person インスタンスの配列です。
                    // Person インスタンスの name プロパティを取り出して結合します。
                    const names = table.seats.map(person => person.name).join(', ');
                    const tableDiv = document.createElement('div');
                    tableDiv.textContent = `Table ${index + 1}: ${names}`;
                    resultDiv.appendChild(tableDiv);
                });

                const costDiv = document.createElement('div');
                costDiv.textContent = `Total Cost: ${bestCost}`;
                resultDiv.appendChild(costDiv);
            }

            document.getElementById('seatingForm').addEventListener('submit', function(event) {
                event.preventDefault();
                // フォーム送信時の処理
                const people = collectPeopleData();
                const { tables } = collectTableData();
                const affinityMatrix = generateAffinityMatrix(people);
                const initialSolution = createInitialSolution(people, tables);
                const { bestSolution, bestCost } = simulatedAnnealing(initialSolution, affinityMatrix, people, 1000, 100.0, 0.99);
                displayResults(bestSolution, bestCost);
            });
        });
    </script>
</body>
</html>
